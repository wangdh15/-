## 数据结构与算法(一)
## 王道烩
## 2018.9.7

算法的五个特征:

- 有穷性
- 确定性
- 可行性
- 输入
- 输出

![](./images/1.png)

![](./images/2.png)

### 基本数据结构

### 二元关系和抽象数据类型

程序=数据结构+算法

数据结构:数据的逻辑结构和存储结构,决定于问题的数学模型 .
算法:问题的处理策略,决定于数学模型的求解方法.
程序:指令集

数据的存储结构既要体现逻辑结构也要服从算法要求.

![](./images/3.png)

二元关系表示了集合M和N中元素之间的某种关系.

![](./images/4.png)

![](./images/5.png)

![](./images/6.png)

![](./images/7.png)

数据在计算机中的存储方式有:

- 顺序存储
- 链式存储

#### 抽象数据类型

![](./images/8.png)

![](./images/9.png)

### 线性表

![](./images/10.png)

#### 顺序存储

线性表中插入一个元素,平均需要移动一半元素

衡量算法的四个标准:

- 正确性
- 可读性
- 健壮性
- 高效率

#### 链式存储

![](./images/11.png)

![](./images/12.png)

为了在插入和删除的时候不用考虑头结点的情况,可以增加一个表头.

![](./images/13.png)

为了能够实现访问前驱,可以使用双向链表

![](./images/14.png)

![](./images/15.png)

![](./images/16.png)

#### 两种存储方式的优缺点

![](./images/17.png)

### 队列

队列是先进先出的数据结构.FIFO

![](./images/18.png)

![](./images/19.png)

队列的应用:

- 缓冲技术
- 排队系统

### 栈

![](./images/20.png)

![](./images/21.png)

#### 栈的应用

- 数制转换
- 括号匹配
- 表达式求值

### 串与串匹配

#### 串匹配算法

已知目标串和模式串,模式匹配就是在目标串中找到一个模式串P相等的子串.

##### 蛮力法

一步一步地移,直到末尾.

![](./images/22.png)

##### KMP算法

KMP算法自左向右匹配,当不匹配时,尽量向右移动最大距离.

![](./images/23.png)

![](./images/24.png)

KMP算法利用了模式串的性质,移动步数只与模式串P有关.
KMP算法的时间复杂度为O(m+n)

![](./images/25.png)

![](./images/26.png)

### 树

树表示以分支关系定义的层级结构.

![](./images/27.png)

![](./images/28.png)

![](./images/29.png)

树的性质:

- 树中节点数目等于所有节点的度数加1.

![](./images/30.png)

![](./images/31.png)

![](./images/32.png)

完全二叉树:深度为h,上面的层数都满了,最后一层从右向左连续缺若干节点.

![](./images/33.png)

![](./images/34.png)

![](./images/35.png)

![](./images/36.png)

要想实现二叉树的非递归算法,可以使用栈结构.如实现中序遍历.访问根节点,然后将根节点入栈,然后访问左孩子,有左孩子就一直入栈,然后没有的话就弹出这个节点,然后将这个节点的右孩子入栈.

先序遍历的非递归实现方式是:访问根节点,然后将右孩子入栈,然后访问左孩子.

后序遍历的非递归实现:要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问.

层序遍历可以使用队列的数据结构来实现.首先根节点入队,然后根节点出队并将其左右孩子分别入队,这样一直下去.

知道一棵二叉树的先序序列和中序序列可以将一个二叉树重建,同理后序序列和中序序列也可以将一个二叉树重建.但是先序序列和后序序列不可以.因为如果一个树只有左孩子后者只有右孩子,那么他们的先序和后序序列都是一样的,但是这两颗树却不一样.

#### 二叉搜索树

一棵树的左子树的节点都不自己小,右子树的节点都比自己大.
二叉搜索树的插入和查找操作类似,找不到就插入这个位置就行.

#### 二叉搜索树的旋转

旋转为了使树更加平衡.

![](./images/37.png)

![](./images/38.png)

![](./images/39.png)


- 定长编码:所有的码子长度相同.
- 变长编码:出现概率大的短码子,出现概率小的长码子.

- 前缀码:每个二进制串表示的字符都不是其他字符的前缀,为解码带来方便.

![](./images/40.png)

### 图

![](./images/41.png)

如果其中的边有序,则为有序图.如果无序,则为无序图.

![](./images/42.png)

![](./images/43.png)

![](./images/44.png)

![](./images/45.png)

欧拉路径:遍历图中每条边且只访问一回的路径.

![](./images/46.png)

#### 图的表示

![](./images/47.png)

![](./images/48.png)

![](./images/49.png)

对于稠密图使用邻接矩阵表示,稀疏图使用邻接表来表示.

#### 图的遍历

从已给的联通图中某一顶点出发,沿着一些边访问图中所有顶点,且使每个顶点仅访问一次,叫做图的遍历.为了避免重复,可设置一个标志顶点是否被访问的辅助数组.

##### 深度优先遍历

![](./images/50.png)

##### 广度优先遍历

![](./images/51.png)

广度优先遍历是分层搜索过程,不能够递归实现.

![](./images/52.png)

#### 最小生成树

![](./images/53.png)

![](./images/54.png)

![](./images/55.png)

时间复杂度是排序的复杂度.

![](./images/56.png)

![](./images/57.png)

#### 最短路径

![](./images/58.png)

![](./images/59.png)

![](./images/60.png)

![](./images/61.png)

![](./images/62.png)

![](./images/63.png)
